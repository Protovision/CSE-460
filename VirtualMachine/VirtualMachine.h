/*
 * VirtualMachine.h
 *
 * Author: Mark Swoope
 * Description:
 * The virtual machine can load a number of object files 
 * generated by the Assembler. Use swap() make the virtual 
 * machine switch context to the next process. Then use run 
 * to execute a number of clock cycles on the current process 
 * that is running.
 *
 * During each context switch, the virtual machine swaps out 
 * the current process's stack with the stack of the next process 
 * to be executed. The ready queue contains processes that are 
 * waiting to use CPU time and the waiting queue contains processes 
 * that are busy with I/O operations.
 *
 */

#ifndef VM_H
#define VM_H

#define VM_ENABLE_ACCOUNTING	1

#include "ISA/ISA.h"

#include <iostream>
#include <algorithm>
#include <fstream>
#include <cstdint>
#include <climits>
#include <list>
#include <queue>

#define VM_MEM_SIZE	256

class OperatingSystem;

class VirtualMachine {
protected:
	struct __attribute__ ((__packed__)) StatusRegister {
		unsigned int	carry:1;	//Carry
		unsigned int	greater:1;	//Greater than
		unsigned int	equal:1;	//Equal to
		unsigned int	less:1;		//Less than
		unsigned int	overflow:1;	//Overflow
		unsigned int	status:3;	//Context status
		unsigned int	io:2;		//I/O register
		unsigned int	reserved:6;
	};

	//Values for StatusRegister::status
	enum {
		ST_AGAIN,	//Program still executing
		ST_HALT,	//Program halted
		ST_RANGE,	//Out of range error
		ST_OVERFLOW,	//Stack overflow
		ST_UNDERFLOW,	//Stack underflow
		ST_ILSEQ,	//Illegal instruction
		ST_READING,	//Read operation
		ST_WRITING	//Write operation
	};

	struct ProgramControlBlock {
		struct Instruction	ir;		//Instruction register
		struct StatusRegister	sr;		//Status register
		uint16_t		r[4];		//General purpose registers
		uint16_t		pc;		//Program counter (relative to base)
		uint16_t		sp;		//Stack pointer
		uint16_t		clock;		//Clock time since last active
		uint16_t		base;		//Address of program
		uint16_t		size;		//Size of program
		char			name[32];	//Name of program (without .o file extension)
		std::fstream		input;		//Standard input
		std::fstream		output;		//Standard output
		std::fstream		stack;		//Stack file

#if VM_ENABLE_ACCOUNTING == 1
		//Process specific accounting information
		int			cpu_time;
		int			waiting_time;
		int			turnaround_time;
		int			io_time;
		int			largest_stack_size;
#endif
	};

	uint16_t	clock;				//Clock
	uint16_t	ip;				//Program image pointer (must be less than sp)
	uint16_t	mem[VM_MEM_SIZE];		//Memory

	std::queue<struct ProgramControlBlock *>	ready;		//Processes waiting for CPU time
	std::queue<struct ProgramControlBlock *>	waiting;	//Processes busy doing I/O
	struct ProgramControlBlock			*running;	//Current running process

#if VM_ENABLE_ACCOUNTING == 1
	//System accounting information
	int	context_switch_ticks;
	int	idle_ticks;
	int	jobs_cpu_time;
	int	total_processes;
#endif
	
public:	
	
#if VM_ENABLE_ACCOUNTING == 1
	VirtualMachine() :
		clock(0), ip(0), ready(), waiting(), running(NULL), mem(),
		context_switch_ticks(0), idle_ticks(0), jobs_cpu_time(0), total_processes(0) {}
#else
	VirtualMachine() :
		clock(0), ip(0), ready(), waiting(), running(NULL), mem() {}

#endif	
	~VirtualMachine();

	//Load program
	bool	load(const char *program);

	//Switch context to another process
	void	swap();

	//Execute clock cycles
	void	run(int cycles);

	//Checks if there are any running programs
	bool	active() const {
		return running != NULL || ready.size() || waiting.size();
	}

	//Get name of process running
	const char 	*getname() const {
		return running->name[0] ? running->name : NULL;
	}

	//Inspect registers
	uint16_t	getr(int i) const { return running->r[i]; }
	uint16_t	getir() const { return *(uint16_t*)&running->ir; }
	uint16_t	getpc() const { return running->pc; }
	uint16_t	getsr() const { return *(uint16_t*)&running->sr; }
	uint16_t	getsp() const { return running->sp; }
	uint16_t	getclock() const { return running->clock; }

	//Inspect memory
	uint16_t	getmem(int loc) const { return mem[loc]; }

	void		printinfo() const;

};

#endif
